# 二叉树
二叉树数据结构可以很好地将一个时间复杂度为Theta(n)的问题转化为Theta(log(n))，降低了算法的时间复杂度。堆排序即利用了这一特性，从而将Theta(n**2)的排序问题转化为Theta(n*log(n))。而二叉树上的各基本操作(增删改查)的运行时间都是O(h)，其中h表示二叉树的高度。

# 红黑树
红黑树是一种特殊的二叉查找树，但在每个节点上增加一个存储位，表示颜色：red或者black。通过节点的颜色着色的限制，这样尽量确保二叉树的叶子节点是平衡的。

在普通二叉树中，各种基本类型的操作运行时间与树的高度成正比。但是，由于二叉树的增删等操作，很多节点的深度会多出其他叶子节点，这样二叉树的时间复杂度会明显增加。为了避免这一缺陷，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。算法设计者给红黑树天剑了如下特性：
1. 每个结点要么是红的，要么是黑的。
2. 根结点是黑的。
3. 每个叶结点，即空结点（NIL）是黑的。
4. 如果一个结点是红的，那么它的俩个儿子都是黑的。
5. 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。

红黑树的基本操作的时间复杂度为O(log(n))。下图即表示一棵红黑树：
![](http://ocrrmln0j.bkt.clouddn.com/8394323_1293613306CGzE.jpg)

# 树的旋转
当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树种某些结点的颜色及指针结构，以达到对红黑树进行插入、删除结点等操作时，红黑树依然能保持它特有的性质（如上文所述的，五点性质）。

树的旋转，分为左旋和右旋，以下借助图来做形象的解释和介绍：
## 左旋
![](http://ocrrmln0j.bkt.clouddn.com/hongheishu_zuoxuan.jpg)

如上图所示：
当在某个结点pivot上，做左旋操作时，我们假设它的右孩子y不是NIL[T]，pivot可以为树内任意右孩子而不是NIL[T]的结点。左旋以pivot到y之间的链为“支轴”进行，它使y成为该孩子树新的根，而y的左孩子b则成为pivot的右孩子。

来看算法导论对此操作的算法实现（以x代替上述的pivot）：

    LEFT-ROTATE(T, x)
    1  y ← right[x] ▹ Set y.
    2  right[x] ← left[y]      ▹ Turn y's left subtree into x's right subtree.

    3  p[left[y]] ← x
    4  p[y] ← p[x]             ▹ Link x's parent to y.
    5  if p[x] = nil[T]
    6     then root[T] ← y
    7     else if x = left[p[x]]
    8             then left[p[x]] ← y
    9             else right[p[x]] ← y
    10  left[y] ← x             ▹ Put x on y's left.
    11  p[x] ← y

## 右旋
右旋与左旋差不多，再此不做详细介绍。
![](http://ocrrmln0j.bkt.clouddn.com/hongheishu_youxuan.jpg)
对于树的旋转，能保持不变的只有原树的搜索性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后可利用旋转和颜色重涂来恢复树的红黑性质。

# 红黑树的基本操作
由于红黑书的增删改操作会破坏其特有的性质，因此在做增删改时比较复杂，需要旋转或者重新涂色等操作。本人这里尚未具体用到红黑树这个数据结构，暂且做个初步了解，尚未详细整理出其实现方法。更多内容推荐阅读《算法导论》这本书，或者查看一下博客链接，看看技术大牛的整理文档：
- <http://www.cnblogs.com/v-July-v/archive/2010/12/29/1983707.html>
- <http://blog.csdn.net/v_JULY_v/article/details/6109153>

# 总结
红黑树的时间复杂度可以确保为O(log(n))，但中插入与删除操作时需要对树做些调整操作。借用以上链接中的一位博主的一句结束：

    只要牢牢抓住红黑树的5个性质不放，而不论是树的左旋还是右旋，不论是红黑树的插入、还是删除，都只为了保持和修复红黑树的5个性质而已。
